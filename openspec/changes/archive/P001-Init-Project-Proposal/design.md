关联 specs 模块：
- specs/dependency-installation-policy
- specs/fastapi-service-skeleton
- specs/nginx-safe-config-update
- specs/release-deploy-and-rollback
- specs/site-provisioning

## Context

本仓库定位为 SiteHub 母版模板：后续多个项目会以此为起点快速落地站点。当前仓库已有 OpenSpec 工作流与少量脚本（如依赖安装网络策略、GitHub 初始化推送），但缺少可重复、可验证、可回滚的“运行与部署基线”，也缺少最小可运行应用骨架来承载后续业务。

约束与假设：

- 运行环境需要兼容 Ubuntu/FnOS，路径需可迁移，模拟生产目录为 `/vol1/1000/MyDocker/web-cluster/sites/`
- 服务端技术栈以 Python 3.10+ 与 FastAPI 为基线
- 端口资源约束为 8085-8095，并需要在模板层面提供可复用的分配/校验机制
- 依赖安装只能使用官方源；当启用缓存服务器时优先使用缓存，否则通过代理访问官方源；禁止国内镜像
- 发布与回滚采用 `releases/<timestamp>` + `current` 软链的原子切换模式
- Nginx 配置更新需要具备备份、预检与失败自动回滚的原子流程

## Goals / Non-Goals

**Goals:**

- 提供一个“最小可运行”的 FastAPI 服务骨架，定义统一入口、健康检查、配置加载与运行方式
- 定义模板级的标准目录与配置约定，使后续项目在不修改基础流程的前提下即可部署上线
- 提供可迁移的发布/回滚契约与实现策略，确保上线可验证、故障可快速回退
- 提供站点初始化与端口管理的契约，使多个站点并存时仍然可控、可审计
- 固化依赖安装网络策略与 Nginx 配置更新的安全策略，并在后续 specs 中可验收

**Non-Goals:**

- 不在本初始化变更中实现具体业务功能、数据库模型或复杂领域能力
- 不绑定单一进程管理方式（systemd/PM2/supervisor 由部署环境选择），只定义可执行入口与最小运行命令
- 不在模板中引入与业务强耦合的第三方组件（如消息队列、缓存集群），除非后续 specs 明确需要

## Decisions

1) 基线能力以“可覆盖大多数项目”的最小集合定义

- 选择：以健康检查、配置加载、启动入口、发布/回滚、目录与端口、依赖策略、Nginx 安全更新作为模板基线能力
- 理由：这些能力是所有项目落地时的共性瓶颈，且可通过规格约束形成可验证的契约
- 备选：只提供应用骨架，不提供部署/回滚与网络策略
- 不选原因：会将关键不确定性与风险推迟到每个项目，导致碎片化与不可迁移

2) 配置形态采用“环境变量为主、YAML 为补充”的双通道

- 选择：运行时关键开关以环境变量为主（如 `SITEHUB_ENV`、`CACHE_SERVER`、站点名/端口），部署描述使用 `sitehub.yaml` 承载（如 release 路径、回滚路径、站点目录）
- 理由：环境变量便于在不同环境注入，YAML 便于表达结构化部署信息并纳入版本管理
- 备选：全部使用环境变量或全部使用 YAML
- 不选原因：全环境变量缺乏结构与可读性；全 YAML 会增加运行时依赖与注入复杂度

3) 发布采用“目录不可变 + 软链切换”的原子策略

- 选择：每次发布生成新的 `releases/<timestamp>` 目录（不可变），通过更新 `current` 软链完成原子切换；保留最近 N 个 releases；提供回滚到任意历史 release
- 理由：软链切换具备原子性，回滚路径明确；不可变目录便于审计与问题定位
- 备选：就地覆盖部署目录
- 不选原因：覆盖式部署难以回滚且易引入半更新状态

4) Nginx 配置更新采用“备份 + 预检 + 失败回滚”的原子流程

- 选择：写入前备份原配置；写入后执行 `nginx -t` 校验；失败则恢复备份并退出；成功才 reload
- 理由：避免错误配置导致服务整体不可用，符合线上稳定性要求
- 备选：直接覆盖并 reload
- 不选原因：配置错误会造成不可控停机，且缺乏自动恢复

5) 端口分配以“显式声明 + 自动分配兜底”的方式实现

- 选择：允许在 `sitehub.yaml`/环境变量中显式声明端口；未声明时从 8085-8095 自动选择未占用端口；同时输出明确的占用检测与冲突报错
- 理由：既能满足固定端口需求，也能提升多站点并行创建的可用性
- 备选：仅自动分配或仅强制显式声明
- 不选原因：仅自动分配不利于长期运维；仅显式声明会增加初始化门槛并放大冲突概率

6) 模板依赖尽量最小化，新增库必须有清晰边界与替代方案

- 选择：优先使用标准库与 FastAPI 基础依赖；若需要解析 YAML 等能力，优先选择成熟、通用、低侵入的库，并在规格中约束其用途与替代路径
- 理由：母版模板需要长期维护，依赖越少迁移成本越低
- 备选：引入较多便捷库以加快开发
- 不选原因：会增加后续项目的供应链风险与维护成本

## Risks / Trade-offs

- [模板过度抽象导致落地困难] → 将规格聚焦在“必须一致的契约”，保留可覆盖/扩展点（例如配置覆盖、可选脚本）
- [不同项目对部署环境的差异] → 将运行入口标准化（可执行命令与健康检查一致），进程管理交由环境选择
- [路径与权限在不同系统不一致] → 在规格中约束路径必须可配置且默认符合模拟生产路径，脚本中严格校验与清晰报错
- [端口扫描/占用检测误判] → 采用多种检测手段（监听端口检查 + 进程占用提示），并允许显式指定端口覆盖
- [依赖安装网络策略不稳定] → 策略分层（缓存优先/代理兜底），失败时输出明确诊断信息并记录日志
